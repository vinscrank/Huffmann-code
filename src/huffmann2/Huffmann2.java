/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package huffmann2;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.PriorityQueue;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

// node class is the basic structure 
// of each node present in the Huffman - tree. 
class HuffmanNode {

    int data;
    char c;
    HuffmanNode left;
    HuffmanNode right;

}

// comparator class helps to compare the node 
// on the basis of one of its attribute. 
// Here we will be compared 
// on the basis of data values of the nodes. 
class MyComparator implements Comparator<HuffmanNode> {

    public int compare(HuffmanNode x, HuffmanNode y) {

        return x.data - y.data;
    }
}

public class Huffmann2 {

    public static HashMap<Character, String> coding = new HashMap<Character, String>();

    public static String finale = "";
    private int[] arrayF;
    public static double nBitCompressione;
    public static double nBitIniziali;

    Huffmann2() {

        System.out.println("taking file as input [input.csv]");
        
    }

    public static void tab(char[] a1, int[] a2) {
        System.out.println("------------------------------------\nCharcter\tFrequency\t");
        System.out.println("------------------------------------");

        for (int i = 0; i < a1.length; i++) {
            System.out.println(a1[i] + "\t\t" + a2[i] + "\t\t");
        }

        System.out.println("------------------------------------");

    }

    //ritorna uns stringa di caratteri tutti distinti usati nell'input
    String carattere(String str) {

        String q = "";
        //int[] freq = new int[str.length()];
        int i, j;

        //Converts given string into character array  
        char string[] = str.toCharArray();

        ///quando trova un carattere doppio nella stringa lo sostituisce con 0
        for (i = 0; i < str.length(); i++) {
            //freq[i] = 1;
            for (j = i + 1; j < str.length(); j++) {
                if (string[i] == string[j]) {
                    //freq[i]++;

                    //Set string[j] to 0 to avoid printing visited character  
                    string[j] = '0';
                }
            }
        }

        for (i = 0; i < str.length(); i++) {

            if (string[i] != ' ' && string[i] != '0') {
                q = q + string[i];
            }

        }
        return q;
    }

    //ritorna un array di frequenze per i rispettivi caratteri
    int[] carattereFreq(String str, String perDim) {

        arrayF = new int[perDim.length()];

        int[] freq = new int[str.length()];
        int i, j, u;
        u = 0;

        //Converts given string into character array  
        char string[] = str.toCharArray();

        for (i = 0; i < str.length(); i++) {
            freq[i] = 1;
            for (j = i + 1; j < str.length(); j++) {
                if (string[i] == string[j]) {
                    freq[i]++;

                    //Set string[j] to 0 to avoid printing visited character  
                    string[j] = '0';
                }
            }
        }

        //Displays the each character and their corresponding frequency  
        for (i = 0; i < freq.length; i++) {

            if (string[i] != ' ' && string[i] != '0') {

                arrayF[u] = freq[i];
                u = u + 1;

            }

        }

        return arrayF;
    }

    // recursive function to print the 
    // huffman-code through the tree traversal. 
    // Here s is the huffman - code generated. 
    public static void printCode(HuffmanNode root, String s) {

        // base case; if the left and right are null 
        // then its a leaf node and we print 
        // the code s generated by traversing the tree. 
        if (root.left
                == null
                && root.right
                == null
                && Character.isLetter(root.c)) {

            // c is the character in the node 
            System.out.println(root.c + ":" + s);
            coding.put(root.c, s);

            return;
        }

        // if we go to left then add "0" to the code. 
        // if we go to the right add"1" to the code. 
        // recursive calls for left and 
        // right sub-tree of the generated tree. 
        printCode(root.left, s + "0");
        printCode(root.right, s + "1");
    }

    public static void huffmann(char[] a1, int[] a2) {

        // numero di caratteri 
        int n = a1.length;

        // crea coda di priorità Q
        PriorityQueue<HuffmanNode> q
                = new PriorityQueue<HuffmanNode>(n, new MyComparator());

        for (int i = 0; i < n; i++) {

            // crea un oggetto nodo Huffman
            // lo aggiunge alla coda di priorità 
            HuffmanNode hn = new HuffmanNode();

            hn.c = a1[i];
            hn.data = a2[i];

            hn.left = null;
            hn.right = null;

            q.add(hn);
        }

        // crea nodo radice
        HuffmanNode root = null;

        // estrae i due valori minimi
        // la dimensione della coda si riduce a 1
        // tutti i nodi vengono estratti
        while (q.size() > 1) {

            // prima estrazione del minimo 
            HuffmanNode x = q.peek();
            q.poll();

            // seconda estrazione del minimo 
            HuffmanNode y = q.peek();
            q.poll();

            // nuovo nodo f
            HuffmanNode f = new HuffmanNode();

            // frequenza di f uguale alla frequenza dei nodi estratti 
            f.data = x.data + y.data;
            f.c = '-';

            f.left = x;

            f.right = y;

            root = f;

            // aggiunge il nodo alla coda di priorità
            q.add(f);
        }

        printCode(root, "");
    }

    //legge dal file di input
    public static String leggi() throws FileNotFoundException, IOException {
        String tutta = "";
        FileReader f;
        f = new FileReader("input.csv");

        BufferedReader b;
        b = new BufferedReader(f);

        String s;

        while (true) {
            s = b.readLine();
            if (s != null) {
                tutta = tutta + s;
            }
            if (s == null) {
                break;
            }

        }

        return tutta;
    }

    public static void decodifica(String codificata) {

        char[] splitCodificata = codificata.toCharArray();

        for (Map.Entry<Character, String> entry : coding.entrySet()) {

            String aumento = "";

            for (int i = 0; i < splitCodificata.length; i++) {
                aumento = aumento + splitCodificata[i];

                if (entry.getValue().equals(aumento)) {

                    finale = finale + entry.getKey();

                    decodifica(codificata.substring(i + 1));

                }
            }
        };

    }

    // main function 
    public static void main(String[] args) throws IOException {
        //acquisice il tempo all'inzio dell'esecuzione del programma
        double inizio = System.currentTimeMillis();

        //recupera dal file di input il testo sotto forma di stringa
        String daLeggere = leggi();

        Huffmann2 hman = new Huffmann2();

        System.out.println("USAGE:java MainClass  ");
        System.out.println("------------------------------------");

        //ritorna  tutti i caretteri del testo input presi una volta sola sotto forma di stringa
        String stringaListaCaratteri = hman.carattere(daLeggere);
        System.out.println("String to encode\n" + daLeggere);

        //ritorna un array di caretteri splittando la stringa contenente i careteri presi una sola volta
        char[] arrayCaratteri = stringaListaCaratteri.toCharArray();

        //ritorna un array di frequenze dei singoli caratteri
        int[] arrayFrequenze = hman.carattereFreq(daLeggere, stringaListaCaratteri);

        //crea tabella frequenze
        tab(arrayCaratteri, arrayFrequenze);

        System.out.println("Coding of all single characters");
        //algoritmo di huffmann
        huffmann(arrayCaratteri, arrayFrequenze);

        //Codifica la stringa in base alla tabella dei caratteri
        String daCodificare = leggi();
        String codificata = "";
        char[] arraydaCod = daCodificare.toCharArray();
        for (int i = 0; i < arraydaCod.length; i++) {
            for (int j = 0; j < arrayCaratteri.length; j++) {
                if (arraydaCod[i] == arrayCaratteri[j]) {
                    String corrispondente = coding.get(arrayCaratteri[j]);
                    codificata = codificata + corrispondente;
                }

            }
        }

        System.out.println("------------------------------------");
        System.out.println("------------------------------------");
        System.out.println("String to encode:\n" + daLeggere);
        System.out.println("Encoding: " + codificata);
        System.out.println("------------------------------------");
        System.out.println("------------------------------------");

        // metodo che decodifica la stringa
        decodifica(codificata);
        System.out.println("Decoding: " + finale);
        
        //calcola bit stringa finale compressa
        nBitCompressione = codificata.length();

        int nBitPerCarattere = (int) (Math.ceil(Math.log(arrayCaratteri.length) / Math.log(2)));
        String stringNoSpazi = daLeggere.replaceAll(" ", "");

        //calcola bit che sarebbero serviti con codice fisso
        nBitIniziali = nBitPerCarattere * stringNoSpazi.length();
        //System.out.println(nBitIniziali);
        double getRatio = (nBitCompressione / nBitIniziali) * 100;
        System.out.println("Compression Ratio: " + getRatio);

       
        double fine = System.currentTimeMillis();
        System.out.println("Execution time: " + (fine - inizio) / 1000 +" s");

    }

} 
    
           
        
  
// This code is contributed by Kunwar Desh Deepak Singh 
